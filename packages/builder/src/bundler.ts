import { resolve, basename, relative } from "node:path";
import * as tstl from "@jackmacwindows/typescript-to-lua";
import * as ts from "typescript";
import { formatPathToLuaPath, trimExtension } from "./utils";
import { log } from "./logger";
import { findLuaRequires } from "@jackmacwindows/typescript-to-lua/dist/transpilation/find-lua-requires";
import { SourceNode } from "source-map";
import { version } from "../package.json";
import { normalizeSlashes } from "@jackmacwindows/typescript-to-lua/dist/utils";
import {
    buildMinimalLualibBundle,
    findUsedLualibFeatures,
} from "@jackmacwindows/typescript-to-lua/dist/LuaLib";

const requireOverride = /* lua */ `
local ____modules = {}
local ____moduleCache = {}
local ____originalRequire = require
local function require(file, ...)
    if ____moduleCache[file] then
        return ____moduleCache[file].value
    end
    if ____modules[file] then
        local module = ____modules[file]
        if select("#", ...) > 0 then
            ____moduleCache[file] = { value = module(...) }
        else
            ____moduleCache[file] = { value = module(file) }
        end
        return ____moduleCache[file].value
    else
        if ____originalRequire then
            return ____originalRequire(file)
        else
            error("module '" .. file .. "' not found")
        end
    end
end
`;

const hashPlaceholder = "{#Hash}";

export const sourceMapTracebackBundlePlaceholder =
    "{#SourceMapTracebackBundle}";

type SourceMapLineData = number | { line: number; file: string };

export function generateHeader({
    entry,
    files,
    minify,
}: {
    entry: string;
    files: string[];
    minify: boolean;
}) {
    const header = `-- Generated by @cc-ts/builder@${version}
-- HeaderSchema: @cc-ts/builder - v0.0.1
-- Entry: ${entry}
-- Hash: ${hashPlaceholder}
-- BuildTime: ${new Date().toISOString()}
-- Files: ${files.join(", ")}
-- Minified: ${minify}`;

    return header;
}

type SourceChunk = string | SourceNode;

export class CCBundler {
    public static createModulePath(pathToResolve: string, program: ts.Program) {
        return formatPathToLuaPath(
            trimExtension(
                tstl.getEmitPathRelativeToOutDir(pathToResolve, program)
            )
        );
    }

    public isBuiltInModule(moduleName: string) {
        return moduleName.startsWith("cc.") || moduleName === "lualib_bundle";
    }

    private moduleSourceNode(
        { code, sourceMapNode }: tstl.ProcessedFile,
        modulePath: string
    ): SourceNode {
        const tableEntryHead = `[${modulePath}] = function(...) \n`;
        const tableEntryTail = " end,\n";

        return this.joinSourceChunks([
            tableEntryHead,
            sourceMapNode ?? code,
            tableEntryTail,
        ]);
    }

    private createModuleTableNode(fileChunks: SourceChunk[]): SourceNode {
        const tableHead = "____modules = {\n";
        const tableEnd = "}\n";

        return this.joinSourceChunks([tableHead, ...fileChunks, tableEnd]);
    }

    private joinSourceChunks(chunks: SourceChunk[]): SourceNode {
        return new SourceNode(null, null, null, chunks);
    }

    private printStackTraceBundleOverride(rootNode: SourceNode): string {
        const map: Record<number, SourceMapLineData> = {};
        const getLineNumber = (line: number, fallback: number) => {
            const data: SourceMapLineData | undefined = map[line];
            if (data === undefined) {
                return fallback;
            }
            if (typeof data === "number") {
                return data;
            }
            return data.line;
        };
        const transformLineData = (data: SourceMapLineData) => {
            if (typeof data === "number") {
                return data;
            }
            return `{line = ${data.line}, file = "${data.file}"}`;
        };

        let currentLine = 1;
        rootNode.walk((chunk, mappedPosition) => {
            if (mappedPosition.line !== undefined && mappedPosition.line > 0) {
                const line = getLineNumber(currentLine, mappedPosition.line);

                map[currentLine] = {
                    line,
                    file: basename(mappedPosition.source),
                };
            }

            currentLine += chunk.split("\n").length - 1;
        });

        const mapItems = Object.entries(map).map(
            ([line, original]) => `["${line}"] = ${transformLineData(original)}`
        );
        const mapString = "{" + mapItems.join(",") + "}";

        return `__TS__SourceMapTraceBack(debug.getinfo(1).short_src, ${mapString});`;
    }

    private modules: Map<string, tstl.ProcessedFile>;
    private moduleDependencies: Map<string, string[]>;
    private visitedModules: Set<string>;

    constructor(
        private files: tstl.ProcessedFile[],
        private program: ts.Program,
        protected emitHost: tstl.EmitHost
    ) {
        this.modules = new Map(
            this.files.map((f) => [
                CCBundler.createModulePath(f.fileName, program),
                f,
            ])
        );

        this.moduleDependencies = new Map();
        this.visitedModules = new Set();

        for (const [moduleName, _] of this.modules) {
            console.log(`Resolving dependencies for module: ${moduleName}`);
            this.resolveModuleDependencies(moduleName);
        }
    }

    private resolveModuleDependencies(moduleName: string): string[] {
        log.verbose(`Resolving dependencies for module: ${moduleName}`);
        const file = this.modules.get(moduleName);
        if (!file) {
            if (
                this.isBuiltInModule(moduleName) ||
                moduleName === "lualib_bundle"
            ) {
                return [];
            }
            throw new Error(`Module ${moduleName} not found`);
        }

        // If we've already fully resolved this module's dependencies, return them
        if (this.moduleDependencies.has(moduleName)) {
            return this.moduleDependencies.get(moduleName)!;
        }

        // If we're currently visiting this module (circular dependency), return empty array
        if (this.visitedModules.has(moduleName)) {
            return [];
        }

        // Mark this module as being visited
        this.visitedModules.add(moduleName);

        const requires = findLuaRequires(file.code);
        if (!requires) {
            this.moduleDependencies.set(moduleName, []);
            this.visitedModules.delete(moduleName);
            return [];
        }
        log.debug(`Found ${requires.length} requires`, requires);

        // Resolve all dependencies for this module
        const dependencies = requires.flatMap(({ requirePath }) => {
            log.debug(`Resolving dependency: ${requirePath}`);
            const deps = this.resolveModuleDependencies(requirePath);
            return [requirePath, ...deps];
        });

        // Store resolved dependencies and remove from visited set
        this.moduleDependencies.set(moduleName, dependencies);
        this.visitedModules.delete(moduleName);

        return dependencies;
    }

    public bundleModule(moduleName: string) {
        const options =
            this.program.getCompilerOptions() as tstl.CompilerOptions;
        const dependencies = this.moduleDependencies.get(moduleName) ?? [];
        const sourceDir = tstl.getSourceDir(this.program);

        const entryFile = this.modules.get(moduleName);
        if (!entryFile) {
            throw new Error(`Module ${moduleName} not found`);
        }

        const files = [entryFile];

        for (const dependency of dependencies) {
            if (
                this.isBuiltInModule(dependency) ||
                dependency === "lualib_bundle"
            ) {
                continue;
            }

            const file = this.modules.get(dependency);
            if (!file) {
                throw new Error(`Module ${dependency} not found`);
            }
            files.push(file);
        }

        const isLuaLibRequired = dependencies.includes("lualib_bundle");
        if (isLuaLibRequired) {
            if (options.tstlVerbose) {
                console.log("Including lualib bundle");
            }
            // Add lualib bundle to source dir 'virtually', will be moved to correct output dir in emitPlan
            const fileName = normalizeSlashes(
                resolve(
                    tstl.getSourceDir(this.program),
                    (options.luaLibName ?? "lualib_bundle") + ".lua"
                )
            );
            const code = this.getLuaLibBundleContent(options, files);
            files.unshift({ fileName, code });
        }

        // For each file: ["<module path>"] = function() <lua content> end,
        const moduleTableEntries = files.map((f) =>
            this.moduleSourceNode(
                f,
                tstl.escapeString(
                    CCBundler.createModulePath(f.fileName, this.program)
                )
            )
        );

        // Create ____modules table containing all entries from moduleTableEntries
        const moduleTable = this.createModuleTableNode(moduleTableEntries);
        const entryPoint = `return require(${tstl.escapeString(
            moduleName
        )}, ...)`;

        const footers: string[] = [];

        const sourceChunks = [
            requireOverride,
            moduleTable,
            ...footers,
            entryPoint,
        ];

        if (!options.noHeader) {
            sourceChunks.unshift(
                generateHeader({
                    entry: moduleName,
                    files: files
                        .filter(
                            (f) =>
                                !this.isBuiltInModule(
                                    CCBundler.createModulePath(
                                        f.fileName,
                                        this.program
                                    )
                                )
                        )
                        .map((f) =>
                            relative(sourceDir, f.fileName).replaceAll(
                                "../node_modules/",
                                ""
                            )
                        ),
                    minify: options.minify === true ? true : false,
                })
            );
        }

        const bundleNode = this.joinSourceChunks(sourceChunks);
        let { code, map } = bundleNode.toStringWithSourceMap();
        code = code.replace(
            sourceMapTracebackBundlePlaceholder,
            this.printStackTraceBundleOverride(bundleNode)
        );
        code = code.replace(hashPlaceholder, Bun.hash(code).toString(36));
        const outputPath = tstl.getEmitPath(entryFile.fileName, this.program);

        return {
            outputPath,
            code,
            sourceMap: map.toString(),
            sourceFiles: files.flatMap((f) => f.sourceFiles ?? []),
        };
    }
    private getLuaLibBundleContent(
        options: ts.CompilerOptions,
        resolvedFiles: tstl.ProcessedFile[]
    ) {
        const luaTarget = tstl.LuaTarget.Cobalt52;
        const usedFeatures = findUsedLualibFeatures(
            luaTarget,
            this.emitHost,
            resolvedFiles.map((f) => f.code)
        );
        return buildMinimalLualibBundle(usedFeatures, luaTarget, this.emitHost);
    }
}
